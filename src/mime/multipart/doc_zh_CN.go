// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ingore

// Package multipart implements MIME multipart parsing, as defined in RFC
// 2046.
//
// The implementation is sufficient for HTTP (RFC 2388) and the multipart
// bodies generated by popular browsers.

// Package multipart implements MIME multipart parsing, as defined in RFC
// 2046.
//
// The implementation is sufficient for HTTP (RFC 2388) and the multipart
// bodies generated by popular browsers.
package multipart

import (
    "bufio"
    "bytes"
    "crypto/rand"
    "errors"
    "fmt"
    "io"
    "io/ioutil"
    "mime"
    "mime/quotedprintable"
    "net/textproto"
    "os"
    "sort"
    "strings"
)

// File is an interface to access the file part of a multipart message.
// Its contents may be either stored in memory or on disk.
// If stored on disk, the File's underlying concrete type will be an *os.File.
type File interface {
	io.Reader
	io.ReaderAt
	io.Seeker
	io.Closer
}


// A FileHeader describes a file part of a multipart request.
type FileHeader struct {
	Filename string
	Header   textproto.MIMEHeader

	content []byte
	tmpfile string
}


// Form is a parsed multipart form.
// Its File parts are stored either in memory or on disk,
// and are accessible via the *FileHeader's Open method.
// Its Value parts are stored as strings.
// Both are keyed by field name.
type Form struct {
	Value map[string][]string
	File  map[string][]*FileHeader
}


// A Part represents a single part in a multipart body.
type Part struct {
	// The headers of the body, if any, with the keys canonicalized
	// in the same fashion that the Go http.Request headers are.
	// For example, "foo-bar" changes case to "Foo-Bar"
	//
	// As a special case, if the "Content-Transfer-Encoding" header
	// has a value of "quoted-printable", that header is instead
	// hidden from this map and the body is transparently decoded
	// during Read calls.
	Header textproto.MIMEHeader

	buffer    *bytes.Buffer
	mr        *Reader
	bytesRead int

	disposition       string
	dispositionParams map[string]string

	// r is either a reader directly reading from mr, or it's a
	// wrapper around such a reader, decoding the
	// Content-Transfer-Encoding
	r io.Reader
}


// Reader is an iterator over parts in a MIME multipart body.
// Reader's underlying parser consumes its input as needed.  Seeking
// isn't supported.

// Reader is an iterator over parts in a MIME multipart body.
// Reader's underlying parser consumes its input as needed. Seeking
// isn't supported.
type Reader struct {
	bufReader *bufio.Reader

	currentPart *Part
	partsRead   int

	nl               []byte // "\r\n" or "\n" (set after seeing first boundary line)
	nlDashBoundary   []byte // nl + "--boundary"
	dashBoundaryDash []byte // "--boundary--"
	dashBoundary     []byte // "--boundary"
}


// A Writer generates multipart messages.
type Writer struct {
	w        io.Writer
	boundary string
	lastpart *part
}


// NewReader creates a new multipart Reader reading from r using the
// given MIME boundary.
//
// The boundary is usually obtained from the "boundary" parameter of
// the message's "Content-Type" header. Use mime.ParseMediaType to
// parse such headers.
func NewReader(r io.Reader, boundary string) *Reader

// NewWriter returns a new multipart Writer with a random boundary,
// writing to w.
func NewWriter(w io.Writer) *Writer

// Open opens and returns the FileHeader's associated File.
func (*FileHeader) Open() (File, error)

// RemoveAll removes any temporary files associated with a Form.
func (*Form) RemoveAll() error

func (*Part) Close() error

// FileName returns the filename parameter of the Part's
// Content-Disposition header.
func (*Part) FileName() string

// FormName returns the name parameter if p has a Content-Disposition
// of type "form-data".  Otherwise it returns the empty string.
func (*Part) FormName() string

// Read reads the body of a part, after its headers and before the
// next part (if any) begins.
func (*Part) Read(d []byte) (n int, err error)

// NextPart returns the next part in the multipart or an error.
// When there are no more parts, the error io.EOF is returned.
func (*Reader) NextPart() (*Part, error)

// ReadForm parses an entire multipart message whose parts have
// a Content-Disposition of "form-data".
// It stores up to maxMemory bytes of the file parts in memory
// and the remainder on disk in temporary files.
func (*Reader) ReadForm(maxMemory int64) (*Form, error)

// Boundary returns the Writer's boundary.
func (*Writer) Boundary() string

// Close finishes the multipart message and writes the trailing
// boundary end line to the output.
func (*Writer) Close() error

// CreateFormField calls CreatePart with a header using the
// given field name.
func (*Writer) CreateFormField(fieldname string) (io.Writer, error)

// CreateFormFile is a convenience wrapper around CreatePart. It creates
// a new form-data header with the provided field name and file name.
func (*Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)

// CreatePart creates a new multipart section with the provided
// header. The body of the part should be written to the returned
// Writer. After calling CreatePart, any previous part may no longer
// be written to.
func (*Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)

// FormDataContentType returns the Content-Type for an HTTP
// multipart/form-data with this Writer's Boundary.
func (*Writer) FormDataContentType() string

// SetBoundary overrides the Writer's default randomly-generated
// boundary separator with an explicit value.
//
// SetBoundary must be called before any parts are created, may only
// contain certain ASCII characters, and must be non-empty and
// at most 69 bytes long.
func (*Writer) SetBoundary(boundary string) error

// WriteField calls CreateFormField and then writes the given value.
func (*Writer) WriteField(fieldname, value string) error

